大家好，我是怪兽。

上节我们创建了插件项目，并且通过Action给插件项目添加了简单的通知功能，但其实在我们的IDEA中，还有一个扩展点的知识也是非常常用的。这节我们通过扩展点开发来使得开发的插件更像IDE的原生功能。

## IntelliJ 平台 IDE 拓展点

在IDEA中，我们可以经常可以看到侧边栏中有一些工具窗口，工具窗口是 IDE 的子窗口，这些窗口通常在主窗口的外边缘，我们称之为工具栏窗口。这些窗口中有按钮、界面，承载了插件的功能点。这种表现形式让插件更加像是 IDE 原生功能。

![image-20230220155823539](assets/image-20230220155823539.png)

如果没有接触过插件开发的小白可能会认为如果要开发这种类似于IDE原生功能的窗口，我们必须要修改IDE的源码才可以。其实不然，IDE给我们提供了丰富扩展点，通过开发对应的扩展点实现就可以很大程度上扩展模拟出IDE很多原生界面功能。由此可以看出IDE的源码扩展性是真的强，正因为扩展性强，也吸引了众多开发者积极开发对应平台的插件，在IDE竞争中，IDEA直接干掉Eclipse也变成了意料之内的事，正如现在的Vscode，正凭借其强大的插件功能占领编辑器市场，干掉一众老牌的Sublime Text、Notead++编辑器等，由此可见生态对于一个产品的重要性！

IntelliJ 平台把工具窗口实现成了一个“拓展点”，用户在开发的插件代码中，基于拓展点声明窗口的定义，定义包括：窗口的名字、图标等，再通过配置的形式注册到 IDE 中，即可看到我们自己的工具窗口。

类似的，在 Settings/Preferences 增加一个新的配置选项，也是 IDE 中的拓展点之一。点击 IDE 中的 Settings/Preferences ，我们打开了 IDE 的配置界面，这个界面中，可以看到很多配置项，若我们所开发的插件在运行的时候，需要用户先添加一些配置信息，可以基于 IDE 的配置拓展点，在Settings/Preferences 中实现我们的配置界面。

IntelliJ 平台和 IDE 捆绑插件（默认安装的插件）中有 1000 多个可用扩展点，今天主要基于上面提到的两个扩展点结合一个翻译的功能需求进行实战。

## 前提要求

在开始之前，我们需要先在[百度翻译开放平台](https://fanyi-api.baidu.com/)注册一个账号，并进行登录，点击管理控制台，获取一下个人翻译APPID和密钥。

>百度翻译开放平台：https://fanyi-api.baidu.com/

百度翻译要求接口请求的`QPS<=1`，这也就意味着个人使用免费。

## 项目实战

在开发之前，我们先说一下开发的主流程，其实每一个扩展点都对应着一个接口，我们需要做的就是定义一个实现类实现该接口，然后实现对应方法中的代码逻辑，最后将该实现类注册到插件配置文件中让IDE感知到即可。

新建一个项目traslator，具体过程不在赘述，创建完成之后，可以简单修改一下resources/META-INF/plugin.xml文件：

```xml
<idea-plugin>
    <id>com.codermonster.translator</id>
    <name>Translator</name>
    <vendor email="buaatys@163.com" url="https://codermonster.top/">码农怪兽</vendor>
    <description><![CDATA[
    翻译插件 | 码农怪兽
  ]]></description>
    <depends>com.intellij.modules.platform</depends>
    <extensions defaultExtensionNs="com.intellij">
    </extensions>
</idea-plugin>
```

该文件是插件的配置文件，主要是用来配置Action和扩展点，上面的信息任意修改即可，重要的是Action和扩展点的声明配置信息。IntelliJ 平台提供了配置拓展点，配置拓展点分为项目级别配置和应用级别配置，项目级别配置指的是配置只对当前窗口打开的项目生效，而应用级别配置则是对 IntelliJ IDE 应用生效，无论打开多少个项目，应用级别的配置可以在打开的多个项目之间共享。

我们先来开发一下翻译插件的配置扩展点，也就是在偏好设置中的配置APPID和密钥的界面，在开发之前，我们需要先在build.gradle.kts文件中添加一个依赖：

```kotlin
dependencies {
    // https://mvnrepository.com/artifact/com.alibaba/fastjson
    implementation("com.alibaba:fastjson:2.0.21")
}
```

除此之外，我们在添加几个配置类，这些配置类不需要自己研究，其实现的功能主要是请求百度翻译接口，获得翻译结果。

```java
// 翻译器工具类
public class TranslatorUtils {

    private final static String transAPIHost = "http://api.fanyi.baidu.com/api/trans/vip/translate";
    public static String appid;
    public static String securityKey;

    public static String getTransResult(String query, String from, String to) {
        Map<String, String> params = buildParams(query, from, to);
        String resp = HttpUtils.get(transAPIHost, params);
        TransResp transResp = JSON.parseObject(resp, TransResp.class);
        if (transResp.getTransResult() == null || transResp.getTransResult().size() == 0) {
            return "翻译出错";
        }
        return transResp.getTransResult().get(0).getDst();
    }

    private static Map<String, String> buildParams(String query, String from, String to) {
        Map<String, String> params = new HashMap<String, String>();
        params.put("q", query);
        params.put("from", from);
        params.put("to", to);
        params.put("appid", appid);
        // 随机数
        String salt = String.valueOf(System.currentTimeMillis());
        params.put("salt", salt);
        // 签名
        String src = appid + query + salt + securityKey; // 加密前的原文
        params.put("sign", MD5Utils.md5(src));
        return params;
    }

    public static class TransResp {

        private String from;
        private String to;
        @JsonProperty("trans_result")
        private List<TransResult> transResult;

        public void setFrom(String from) {
            this.from = from;
        }

        public String getFrom() {
            return this.from;
        }

        public void setTo(String to) {
            this.to = to;
        }

        public String getTo() {
            return this.to;
        }

        public void setTransResult(List<TransResult> transResult) {
            this.transResult = transResult;
        }

        public List<TransResult> getTransResult() {
            return this.transResult;
        }
    }

    public static class TransResult {
        private String src;
        private String dst;

        public void setSrc(String src) {
            this.src = src;
        }

        public String getSrc() {
            return this.src;
        }

        public void setDst(String dst) {
            this.dst = dst;
        }

        public String getDst() {
            return this.dst;
        }
    }
}
```

```java
// MD5工具类
public class MD5Utils {

    // 首先初始化一个字符数组，用来存放每个16进制字符
    private static final char[] hexDigits = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};

    /**
     * 获得一个字符串的MD5值
     *
     * @param input 输入的字符串
     * @return 输入字符串的MD5值
     */
    public static String md5(String input) {
        if (input == null) return null;

        try {
            // 拿到一个MD5转换器（如果想要SHA1参数换成”SHA1”）
            MessageDigest messageDigest = MessageDigest.getInstance("MD5");
            // 输入的字符串转换成字节数组
            byte[] inputByteArray = input.getBytes("utf-8");
            // inputByteArray是输入字符串转换得到的字节数组
            messageDigest.update(inputByteArray);
            // 转换并返回结果，也是字节数组，包含16个元素
            byte[] resultByteArray = messageDigest.digest();
            // 字符数组转换成字符串返回
            return byteArrayToHex(resultByteArray);
        } catch (Exception e) {
            return null;
        }
    }

    /**
     * 获取文件的MD5值
     */
    public static String md5(File file) {
        try {
            if (!file.isFile()) {
                System.err.println("文件" + file.getAbsolutePath() + "不存在或者不是文件");
                return null;
            }
            FileInputStream in = new FileInputStream(file);
            String result = md5(in);
            in.close();
            return result;
        } catch (IOException e) {
            e.printStackTrace();
        }

        return null;
    }

    public static String md5(InputStream in) {

        try {
            MessageDigest messagedigest = MessageDigest.getInstance("MD5");
            byte[] buffer = new byte[1024];
            int read = 0;
            while ((read = in.read(buffer)) != -1) {
                messagedigest.update(buffer, 0, read);
            }
            in.close();
            return byteArrayToHex(messagedigest.digest());
        } catch (NoSuchAlgorithmException | IOException e) {
            e.printStackTrace();
        }

        return null;
    }

    private static String byteArrayToHex(byte[] byteArray) {
        // new一个字符数组，这个就是用来组成结果字符串的（解释一下：一个byte是八位二进制，也就是2位十六进制字符（2的8次方等于16的2次方））
        char[] resultCharArray = new char[byteArray.length * 2];
        // 遍历字节数组，通过位运算（位运算效率高），转换成字符放到字符数组中去
        int index = 0;
        for (byte b : byteArray) {
            resultCharArray[index++] = hexDigits[b >>> 4 & 0xf];
            resultCharArray[index++] = hexDigits[b & 0xf];
        }
        // 字符数组组合成字符串返回
        return new String(resultCharArray);

    }
}
```

```java
// HTTP工具类
public class HttpUtils {

    protected static final int SOCKET_TIMEOUT = 10000; // 10S
    protected static final String GET = "GET";

    public static String get(String host, Map<String, String> params) {
        try {
            // 设置SSLContext
            SSLContext sslcontext = SSLContext.getInstance("TLS");
            sslcontext.init(null, new TrustManager[]{myX509TrustManager}, null);

            String sendUrl = getUrlWithQueryString(host, params);

            // System.out.println("URL:" + sendUrl);

            URL uri = new URL(sendUrl); // 创建URL对象
            HttpURLConnection conn = (HttpURLConnection) uri.openConnection();
            if (conn instanceof HttpsURLConnection) {
                ((HttpsURLConnection) conn).setSSLSocketFactory(sslcontext.getSocketFactory());
            }

            conn.setConnectTimeout(SOCKET_TIMEOUT); // 设置相应超时
            conn.setRequestMethod(GET);
            int statusCode = conn.getResponseCode();
            if (statusCode != HttpURLConnection.HTTP_OK) {
                System.out.println("Http错误码：" + statusCode);
            }

            // 读取服务器的数据
            InputStream is = conn.getInputStream();
            BufferedReader br = new BufferedReader(new InputStreamReader(is));
            StringBuilder builder = new StringBuilder();
            String line;
            while ((line = br.readLine()) != null) {
                builder.append(line);
            }

            String text = builder.toString();

            close(br); // 关闭数据流
            close(is); // 关闭数据流
            conn.disconnect(); // 断开连接

            return text;
        } catch (IOException | KeyManagementException | NoSuchAlgorithmException e) {
            e.printStackTrace();
        }

        return null;
    }

    public static String getUrlWithQueryString(String url, Map<String, String> params) {
        if (params == null) {
            return url;
        }

        StringBuilder builder = new StringBuilder(url);
        if (url.contains("?")) {
            builder.append("&");
        } else {
            builder.append("?");
        }

        int i = 0;
        for (String key : params.keySet()) {
            String value = params.get(key);
            if (value == null) { // 过滤空的key
                continue;
            }

            if (i != 0) {
                builder.append('&');
            }

            builder.append(key);
            builder.append('=');
            builder.append(encode(value));

            i++;
        }

        return builder.toString();
    }

    protected static void close(Closeable closeable) {
        if (closeable != null) {
            try {
                closeable.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * 对输入的字符串进行URL编码, 即转换为%20这种形式
     *
     * @param input 原文
     * @return URL编码. 如果编码失败, 则返回原文
     */
    public static String encode(String input) {
        if (input == null) {
            return "";
        }

        return URLEncoder.encode(input, StandardCharsets.UTF_8);
    }

    private static final TrustManager myX509TrustManager = new X509TrustManager() {

        @Override
        public X509Certificate[] getAcceptedIssuers() {
            return null;
        }

        @Override
        public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {
        }

        @Override
        public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {
        }
    };
}
```

























## 源码及文档下载

本教程的所有文档及源码可以关注微信公众号：码农怪兽，在公众号中回复关键字“IDEA插件开发”获取。
